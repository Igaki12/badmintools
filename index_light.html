<!DOCTYPE html>

<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>バドミントン動作分析アプリ - 軽量版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 軽量版カスタムCSS */
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            color: #1f2937;
        }
        
        .simple-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .simple-button {
            background: #3b82f6;
            color: white;
            border: 1px solid #3b82f6;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .simple-button:hover {
            background: #2563eb;
        }
        
        .simple-button:disabled {
            background: #cbd5e1;
            border-color: #cbd5e1;
            cursor: not-allowed;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        .text-accent {
            color: #dc2626;
        }
        
        .text-secondary {
            color: #6b7280;
        }
        
        /* スライダーのつまみのスタイル */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fb923c;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #fb923c;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }

        .analysis-canvas {
            border: 1px solid #e5e7eb;
            background-color: #f9fafb;
        }
        
        #cropOverlayCanvas {
            touch-action: none;
            cursor: grab;
        }
    </style>

</head>

<body class="p-4 min-h-screen">
    <div class="container mx-auto simple-card p-4">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-accent">バドミントン動作分析（軽量版）</h1>
            <p class="text-secondary mt-2">動画から選手の動きを捉え、軌跡とヒートマップで可視化します。</p>
            
            <!-- モデル切り替えボタン -->
            <div class="flex justify-center gap-2 mt-4">
                <button class="simple-button bg-orange-500" disabled>軽量版</button>
                <a href="index.html" class="simple-button">標準版</a>
                <a href="index_heavy.html" class="simple-button">重量版</a>
            </div>
        </header>

<!-- Section 1: Video Upload and Display -->
    <section class="mb-6 p-4 simple-card">
        <h2 class="text-xl font-semibold mb-3 text-accent">1. 動画の準備</h2>
        <input type="file" id="fileInput" accept="video/*" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-orange-100 file:text-orange-700 hover:file:bg-orange-200 disabled:opacity-50 transition-colors" disabled>
        
        <p id="loadingTxt" class="text-sm text-secondary mt-2">AIモデルを読み込んでいます... 初回は数秒～数十秒かかることがあります。</p>
        
        <div id="videoContainer" class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-4 items-start">
            <div>
                <h3 class="text-lg font-medium text-gray-700 mb-1">オリジナル動画</h3>
                <video id="video" controls class="w-full rounded-md shadow-md aspect-video hidden bg-gray-200"></video>
            </div>
            <div class="relative">
                <h3 class="text-lg font-medium text-gray-700 mb-1">姿勢推定オーバーレイ</h3>
                <div id="poseCanvasContainer" class="w-full aspect-video">
                    <canvas id="poseCanvas" class="w-full rounded-md shadow-md aspect-video hidden bg-gray-200"></canvas>
                    <canvas id="cropOverlayCanvas" class="absolute top-0 left-0 w-full h-full hidden"></canvas>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 2: Recording Controls -->
    <section class="mb-6 p-4 simple-card text-center">
        <h2 class="text-xl font-semibold mb-3 text-accent">2. 録画と座標取得</h2>
        <div class="flex flex-wrap justify-center gap-2">
            <button id="startButton" class="simple-button disabled:opacity-50" disabled>録画開始</button>
            <button id="stopButton" class="simple-button disabled:opacity-50" disabled>録画停止</button>
            <a id="downloadLink" href="#" download="badminton_analysis.webm" class="hidden simple-button">録画をダウンロード</a>
        </div>
    </section>

    <!-- Section 3: Movement Analysis -->
    <section id="analysisSection" class="mb-6 p-4 simple-card hidden">
        <h2 class="text-xl font-semibold mb-3 text-accent">3. 移動・ショット分析結果</h2>
        
        <div id="correctionControls" class="mb-4 p-4 simple-card">
            <h3 class="text-lg font-semibold mb-2 text-accent">座標の補正</h3>
            <p class="text-sm text-secondary mb-3">動画内のコートの歪みを補正し、より正確な軌跡を表示します。</p>
            <button id="startCropButton" class="simple-button">コートに合わせてトリミング</button>
            <button id="applyCorrectionButton" class="simple-button ml-2 hidden">補正を適用</button>
            <button id="resetCorrectionButton" class="simple-button ml-2 hidden">補正をリセット</button>
            <p id="cropInstructions" class="text-sm text-indigo-700 mt-2 hidden">コートの四隅をドラッグして調整してください。</p>
        </div>

        <button id="analyzeButton" class="simple-button w-full mb-4">分析を開始・更新</button>

        <div id="visualizationControls" class="mt-4 hidden">
            
            <div class="mb-4">
                <label for="timeSlider" class="block mb-1 text-sm font-medium text-secondary">表示する時間範囲 (スライダーで調整):</label>
                <input type="range" id="timeSlider" min="0" max="100" value="100" step="0.1" class="w-full h-3 bg-orange-200 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-xs text-secondary mt-1">
                    <span id="sliderMinTime">0.0s</span>
                    <span id="sliderCurrentTimeLabel" class="font-semibold">現在: <span id="sliderCurrentTime">0.0s</span></span>
                    <span id="sliderMaxTime">0.0s</span>
                </div>
            </div>
            
            <div id="shotButtonsContainer" class="mt-2 mb-6 flex flex-wrap items-center gap-2"></div>
            
            <!-- エクスポート機能 -->
            <div class="mb-4 p-4 simple-card">
                <h3 class="text-lg font-semibold mb-2 text-accent">データエクスポート</h3>
                <div class="flex flex-wrap gap-2">
                    <button id="exportJSONButton" class="simple-button">JSON形式でエクスポート</button>
                    <button id="exportCSVButton" class="simple-button">CSV形式でエクスポート</button>
                    <button id="exportImageButton" class="simple-button">画像をエクスポート</button>
                    <button id="generateReportButton" class="simple-button">レポート生成</button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-4">
                <div>
                    <h3 class="text-lg font-semibold mb-2 text-accent">移動軌跡</h3>
                    <p class="text-xs text-secondary mb-1">青: 左足首, 赤: 右足首</p>
                    <canvas id="trajectoryCanvas" class="w-full aspect-[1340/610] analysis-canvas rounded-md shadow"></canvas>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-2 text-accent">ヒートマップ</h3>
                    <p class="text-xs text-secondary mb-1">滞在頻度が高いほど赤く表示</p>
                    <canvas id="heatmapCanvas" class="w-full aspect-[1340/610] analysis-canvas rounded-md shadow"></canvas>
                </div>
                <div id="wristAnalysisContainer" class="lg:col-span-2 hidden">
                    <h3 class="text-lg font-semibold mb-2 text-accent">手首の速度</h3>
                    <p class="text-xs text-secondary mb-1">青: 左手首, 赤: 右手首。赤い点線はショット判定の速度閾値。</p>
                    <canvas id="wristVelocityCanvas" class="w-full h-48 analysis-canvas rounded-md shadow"></canvas>
                </div>
            </div>

            <!-- ショット閾値調整 -->
            <div class="mb-4 p-4 simple-card">
                <h3 class="text-lg font-semibold mb-2 text-accent">ショット検出設定</h3>
                <div class="mb-3">
                    <label for="thresholdSlider" class="block mb-1 text-sm font-medium text-secondary">速度閾値 (ピクセル/秒): <span id="thresholdValue">5000</span></label>
                    <input type="range" id="thresholdSlider" min="500" max="10000" value="5000" step="100" class="w-full h-3 bg-orange-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-secondary mt-1">
                        <span>500</span>
                        <span>10000</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 4: Data Export -->
    <section class="mb-8 p-4 glass-card section-hover animate-fade-in">
        <div class="flex justify-between items-center">
            <h3 class="text-xl font-bold text-gray-700 dark:text-gray-200">データエクスポート</h3>
            <button id="exportToggleButton" class="md:hidden text-sm text-blue-600 dark:text-blue-400 flex items-center">
                <span id="exportToggleText">表示</span>
                <svg id="exportToggleIcon" class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
        </div>
        <div id="exportButtonsContainer" class="hidden md:block mt-4">
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                <button id="exportJSONButton" class="btn btn-secondary">JSON形式</button>
                <button id="exportCSVButton" class="btn btn-secondary">CSV形式</button>
                <button id="exportImageButton" class="btn btn-secondary">画像保存</button>
                <button id="generateReportButton" class="btn btn-secondary">レポート生成</button>
            </div>
        </div>
    </section>

    <!-- Section 5: Help -->
    <section class="mb-6 p-4 simple-card">
        <h2 class="text-xl font-semibold mb-3 text-accent">ヘルプ・使い方</h2>
        <ol class="list-decimal list-inside text-left">
            <li class="text-secondary mb-2">
                <span class="font-medium text-gray-800">動画のアップロード:</span> 録画ボタンをクリックして、バドミントンの動画をアップロードします。
            </li>
            <li class="text-secondary mb-2">
                <span class="font-medium text-gray-800">録画と座標取得:</span> 録画開始ボタンをクリックして、選手の動きを録画します。録画停止後、自動で分析が行われます。
            </li>
            <li class="text-secondary mb-2">
                <span class="font-medium text-gray-800">移動・ショット分析:</span> 録画した動画から、選手の移動軌跡やショットを分析します。
            </li>
            <li class="text-secondary mb-2">
                <span class="font-medium text-gray-800">データエクスポート:</span> 分析結果をJSON, CSV, 画像, レポート形式でエクスポートできます。
            </li>
        </ol>
    </section>
</div>

<script type="module">
    import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.10";

    // DOM Elements
    const fileInput = document.getElementById('fileInput');
    const video = document.getElementById('video');
    const poseCanvas = document.getElementById('poseCanvas');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const downloadLink = document.getElementById('downloadLink');
    const loadingTxt = document.getElementById('loadingTxt');
    const analysisSection = document.getElementById('analysisSection');
    const analyzeButton = document.getElementById('analyzeButton');
    const visualizationControls = document.getElementById('visualizationControls');
    const timeSlider = document.getElementById('timeSlider');
    const sliderMinTime = document.getElementById('sliderMinTime');
    const sliderCurrentTime = document.getElementById('sliderCurrentTime');
    const sliderMaxTime = document.getElementById('sliderMaxTime');
    const trajectoryCanvas = document.getElementById('trajectoryCanvas');
    const heatmapCanvas = document.getElementById('heatmapCanvas');
    const correctionControls = document.getElementById('correctionControls');
    const startCropButton = document.getElementById('startCropButton');
    const applyCorrectionButton = document.getElementById('applyCorrectionButton');
    const resetCorrectionButton = document.getElementById('resetCorrectionButton');
    const cropInstructions = document.getElementById('cropInstructions');
    const cropOverlayCanvas = document.getElementById('cropOverlayCanvas');
    const poseCanvasContainer = document.getElementById('poseCanvasContainer');
    
    // *** ADDED *** DOM Elements for Shot Analysis
    const wristAnalysisContainer = document.getElementById('wristAnalysisContainer');
    const wristVelocityCanvas = document.getElementById('wristVelocityCanvas');
    const shotButtonsContainer = document.getElementById('shotButtonsContainer');
    
    // *** ADDED *** DOM Elements for Threshold Control
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdValue = document.getElementById('thresholdValue');
    const updateThresholdButton = document.getElementById('updateThresholdButton');
    
  
    
    // *** ADDED *** DOM Elements for Export Functions
    const exportJSONButton = document.getElementById('exportJSONButton');
    const exportCSVButton = document.getElementById('exportCSVButton');
    const exportImageButton = document.getElementById('exportImageButton');
    const generateReportButton = document.getElementById('generateReportButton');
    const exportToggleButton = document.getElementById('exportToggleButton');
    const exportToggleText = document.getElementById('exportToggleText');
    const exportToggleIcon = document.getElementById('exportToggleIcon');
    const exportButtonsContainer = document.getElementById('exportButtonsContainer');

    // Canvas Contexts
    let ctxPose = poseCanvas.getContext('2d');
    let ctxTrajectory = trajectoryCanvas.getContext('2d');
    let ctxHeatmap = heatmapCanvas.getContext('2d');
    let ctxCropOverlay = cropOverlayCanvas.getContext('2d');
    let ctxWristVelocity = wristVelocityCanvas.getContext('2d'); // *** ADDED ***

    // MediaRecorder & PoseLandmarker
    let mediaRecorder;
    let recordedChunks = [];
    let poseLandmarker = null;
    let drawingUtilsPose = null;
    let runningMode = 'VIDEO';
    let lastVideoTime = -1;
    let anklePositions = []; 
    let wristPositions = []; // *** ADDED ***
    let stream = null; 

    // Analysis & Correction State
    const HEATMAP_GRID_SIZE = 25;
    let videoDuration = 0;
    // let cropPoints = []; → Webstorageから取得するように変更
    let cropPoints = JSON.parse(localStorage.getItem('cropPoints')) || [];
    if (!cropPoints || cropPoints.length !== 4) {
        // 初期値は設定しない
        cropPoints = [];
    }
    let correctedAnklePositions = [];
    let correctedWristPositions = []; // *** ADDED ***
    let shotTimes = []; // *** ADDED ***
    let homographyMatrix = null;
    let isCorrectionApplied = false;
    let isCroppingMode = false;
    let isDragging = false;
    let draggedPointIndex = -1;
    const CROP_HANDLE_RADIUS = 45; // 大きくしてドラッグしやすくするように修正

    // Badminton court dimensions (for aspect ratio)
    const COURT_WIDTH = 610;
    const COURT_LENGTH = 1340;
    // *** ADDED *** Threshold for shot detection (pixels/second). Needs tuning.
    // let SHOT_VELOCITY_THRESHOLD = parseInt(localStorage.getItem('shotVelocityThreshold')) || 5000; // Made this variable to allow dynamic updates 
    let SHOT_VELOCITY_THRESHOLD = JSON.parse(localStorage.getItem('shotVelocityThreshold')) || 5000; // Made this variable to allow dynamic updates

      // Initialize threshold slider and value from localStorage
    thresholdSlider.value = SHOT_VELOCITY_THRESHOLD;
    thresholdValue.textContent = SHOT_VELOCITY_THRESHOLD;

    async function initPoseLandmarker() {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/wasm"
            );
            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    // modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
                    // delegate: "GPU"
                    // api/pose_landmarker_lite.task からローカルでダウンロードしたモデルを使用
                    modelAssetPath: "api/pose_landmarker_lite.task",
                    delegate: "GPU",
                },
                runningMode: runningMode,
                numPoses: 1
            });
            console.log("PoseLandmarker initialized");
            loadingTxt.textContent = "モデル読み込み完了。動画を選択してください。";
            fileInput.disabled = false;
        } catch (err) {
            console.error("Error initializing PoseLandmarker:", err);
            loadingTxt.textContent = "モデル読み込みに失敗しました。ページをリロードしてください。";
        }
    }

    initPoseLandmarker();

    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const fileURL = URL.createObjectURL(file);
        video.src = fileURL;
        video.style.display = 'block';
        poseCanvas.style.display = 'block';
        
        video.onloadedmetadata = () => {
            videoDuration = video.duration;
            poseCanvas.width = video.videoWidth;
            poseCanvas.height = video.videoHeight;
            cropOverlayCanvas.width = video.videoWidth;
            cropOverlayCanvas.height = video.videoHeight;
            
            [trajectoryCanvas, heatmapCanvas].forEach(cvs => {
                cvs.width = COURT_LENGTH; 
                cvs.height = COURT_WIDTH;
            });
            // *** ADDED *** Set wrist velocity canvas dimensions
            wristVelocityCanvas.width = 1200; // High resolution for sharp text/lines
            wristVelocityCanvas.height = 400;

            drawingUtilsPose = new DrawingUtils(ctxPose);
            startButton.disabled = false;
            
            resetAllAnalysis(); 
            loadingTxt.textContent = "動画の準備ができました。録画を開始できます。";
        };
        video.onerror = () => {
            console.error("Error loading video file.");
            loadingTxt.textContent = "エラー: 動画ファイルの読み込みに失敗しました。";
        }
    });
    
    function resetAllAnalysis() {
        analysisSection.classList.add('hidden');
        visualizationControls.classList.add('hidden');
        correctionControls.style.display = 'none';
        wristAnalysisContainer.classList.add('hidden'); // *** ADDED ***
        stopCroppingMode();
        anklePositions = [];
        wristPositions = []; // *** ADDED ***
        correctedAnklePositions = [];
        correctedWristPositions = []; // *** ADDED ***
        shotTimes = []; // *** ADDED ***
        shotButtonsContainer.innerHTML = ''; // *** ADDED ***
        recordedChunks = [];
        isCorrectionApplied = false;
        homographyMatrix = null;
        downloadLink.classList.add('hidden');
        analyzeButton.disabled = true;
    }

    async function drawFrame() {
        if (!video || video.paused || video.ended || video.readyState < 2) {
            requestAnimationFrame(drawFrame);
            return;
        }
        
        ctxPose.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
        ctxPose.drawImage(video, 0, 0, poseCanvas.width, poseCanvas.height);

        if (poseLandmarker && video.currentTime !== lastVideoTime) {
            const startTimeMs = performance.now();
            lastVideoTime = video.currentTime;

            poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
                if (result.landmarks && result.landmarks.length > 0) {
                    const landmarks = result.landmarks[0];
                    if (drawingUtilsPose) {
                        drawingUtilsPose.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS, { color: '#FF8A65', lineWidth: 2 });
                        drawingUtilsPose.drawLandmarks(landmarks, { color: '#FFAB91', radius: 3 });
                    }
                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        // Record ankle positions
                        const leftAnkle = landmarks[27];
                        const rightAnkle = landmarks[28];
                        if (leftAnkle && rightAnkle) {
                            anklePositions.push({
                                time: video.currentTime,
                                leftAnkle: { x: leftAnkle.x, y: leftAnkle.y, visibility: leftAnkle.visibility },
                                rightAnkle: { x: rightAnkle.x, y: rightAnkle.y, visibility: rightAnkle.visibility }
                            });
                        }
                        // *** ADDED *** Record wrist positions
                        const leftWrist = landmarks[15];
                        const rightWrist = landmarks[16];
                        if (leftWrist && rightWrist) {
                            wristPositions.push({
                                time: video.currentTime,
                                leftWrist: { x: leftWrist.x, y: leftWrist.y, visibility: leftWrist.visibility },
                                rightWrist: { x: rightWrist.x, y: rightWrist.y, visibility: rightWrist.visibility }
                            });
                        }
                    }
                }
            });
        }
        if (isCroppingMode) {
            drawCropOverlay();
        }
        requestAnimationFrame(drawFrame);
    }
    
    video.addEventListener('play', () => {
        lastVideoTime = -1;
        requestAnimationFrame(drawFrame);
    });
    
    video.addEventListener('ended', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            stopRecording();
        }
    });

    startButton.addEventListener('click', () => {
        if (poseCanvas.captureStream) {
            stream = poseCanvas.captureStream(30);
        } else {
            console.error("captureStream not supported.");
            loadingTxt.textContent = "エラー: お使いのブラウザは録画機能に対応していません。";
            return;
        }

        video.play();
        resetAllAnalysis();
        
        try {
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
        } catch (e) {
             mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        }
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            downloadLink.href = url;
            downloadLink.classList.remove('hidden');
            
            analysisSection.classList.remove('hidden');
            correctionControls.style.display = 'block'; 
            analyzeButton.disabled = false;
            visualizationControls.classList.add('hidden'); 

            const recordedPositions = anklePositions.length > 0 ? anklePositions : wristPositions;
            if (recordedPositions.length > 0) {
                const maxTime = recordedPositions[recordedPositions.length - 1].time;
                timeSlider.max = maxTime.toFixed(1);
                timeSlider.value = maxTime.toFixed(1);
                sliderMaxTime.textContent = `${maxTime.toFixed(1)}s`;
                sliderCurrentTime.textContent = `${maxTime.toFixed(1)}s`;
            }
            sliderMinTime.textContent = "0.0s";
            loadingTxt.textContent = "録画が完了しました。「分析を開始」または「コートに合わせてトリミング」を行ってください。";
        };
        
        mediaRecorder.start();
        loadingTxt.textContent = "録画中です...";
        startButton.disabled = true;
        stopButton.disabled = false;
    });

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null; 
        }
        startButton.disabled = false;
        stopButton.disabled = true;
    }
    stopButton.addEventListener('click', stopRecording);

    analyzeButton.addEventListener('click', () => {
        if (anklePositions.length === 0 && wristPositions.length === 0) {
            loadingTxt.textContent = "情報: 分析データがありません。先に動画を録画してください。";
            return;
        }
        visualizationControls.classList.remove('hidden');
        wristAnalysisContainer.classList.remove('hidden'); // *** ADDED *** Show wrist graph container

        // *** ADDED *** Perform shot detection
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
        shotTimes = detectShots(velocities, SHOT_VELOCITY_THRESHOLD);
        createShotButtons(shotTimes);

        drawAnalysis(parseFloat(timeSlider.value));
        loadingTxt.textContent = "移動分析とショット分析の結果を表示しています。";
        // スライダーの最大値を設定
        videoDuration = video.duration;
        sliderMaxTime.textContent = videoDuration.toFixed(1) + 's';
        timeSlider.max = videoDuration;
        timeSlider.value = 0;
        drawAnalysis(0);
        visualizationControls.classList.remove('hidden');
        correctionControls.classList.remove('hidden');
        wristAnalysisContainer.classList.remove('hidden'); // *** ADDED ***
    });

    // Data export toggle for mobile
    exportToggleButton.addEventListener('click', () => {
        const isHidden = exportButtonsContainer.classList.contains('hidden');
        exportButtonsContainer.classList.toggle('hidden');
        exportToggleText.textContent = isHidden ? '非表示' : '表示';
        exportToggleIcon.innerHTML = isHidden ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>' : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>';
    });

    // Threshold control event listeners
    thresholdSlider.addEventListener('input', () => {
        thresholdValue.textContent = thresholdSlider.value;
        SHOT_VELOCITY_THRESHOLD = parseInt(thresholdSlider.value);
        localStorage.setItem('shotVelocityThreshold', SHOT_VELOCITY_THRESHOLD.toString());
        if (wristPositions.length > 0 || correctedWristPositions.length > 0) {
            const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
            const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
            shotTimes = detectShots(velocities, SHOT_VELOCITY_THRESHOLD);
            createShotButtons(shotTimes);
            loadingTxt.textContent = `ショット検出閾値を ${SHOT_VELOCITY_THRESHOLD} に更新しました。`;
        }
        drawAnalysis(parseFloat(timeSlider.value));
        sliderCurrentTime.textContent = `${parseFloat(timeSlider.value).toFixed(1)}s`;
        sliderMaxTime.textContent = `${parseFloat(timeSlider.value).toFixed(1)}s`;
        sliderMinTime.textContent = "0.0s";
    });
    
    timeSlider.addEventListener('input', () => {
        const currentTime = parseFloat(timeSlider.value);
        sliderCurrentTime.textContent = `${currentTime.toFixed(1)}s`;
        if (!visualizationControls.classList.contains('hidden')) { 
             drawAnalysis(currentTime);
        }
    });
    
    function drawAnalysis(currentTime) {
        // Draw Ankle Analysis
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const filteredAnkleData = ankleData.filter(p => p.time <= currentTime);
        
        [trajectoryCanvas, heatmapCanvas].forEach(canvas => {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(isCorrectionApplied) {
                drawBadmintonCourt(ctx);
            }
        });

        if (filteredAnkleData.length > 0) {
            drawTrajectory(filteredAnkleData, isCorrectionApplied, trajectoryCanvas);
            drawHeatmap(filteredAnkleData, isCorrectionApplied, heatmapCanvas);
            loadingTxt.textContent = isCorrectionApplied ? "補正後の分析結果を表示中..." : "移動分析結果を表示中...";
        }

        // *** ADDED *** Draw Wrist Analysis
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
        drawWristVelocityGraph(velocities, currentTime);
    }
    
    function drawBadmintonCourt(ctx) {
// コートの描画
// バドミントンコートの公式の大きさに則して、サイドライン、センターライン、サービスラインを描画する

        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        ctx.fillStyle = '#f0fdf4';
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = '#4b5563';
        ctx.lineWidth = w / 200;
        // サイドライン(ダブルス)
        ctx.strokeRect(w*0.005,h*0.005,w*0.99,h*0.99);
        // サイドライン(シングルス) |440mm|2550mm|2550mm|440mm|
        ctx.beginPath(); ctx.moveTo(w * 0.074, h*0.005); ctx.lineTo(w * 0.074, h*0.995); ctx.moveTo(w * 0.926, h*0.005); ctx.lineTo(w * 0.926, h*0.995); ctx.stroke();
        // サービスライン - 2000mm - 3900mm - 760mm - 
        ctx.beginPath(); ctx.moveTo(w*0.005, h * 2000/(2000+3900+760)); ctx.lineTo(w*0.995, h * 2000/(2000+3900+760)); ctx.moveTo(w*0.005, h * (2000 + 3900)/(2000+3900+760)); ctx.lineTo(w*0.995, h * (2000 + 3900)/(2000+3900+760)); ctx.stroke();
        // センターライン 左右のサービスコートを分ける
        ctx.beginPath(); ctx.moveTo(w / 2, h * 2000/(2000+3900+760)); ctx.lineTo(w / 2, h*0.995);ctx.stroke();
    }

    function drawTrajectory(positions, isCorrected, canvas) { //移動軌跡の描画
        const ctx = canvas.getContext('2d');
        ctx.lineWidth = 4; // 太さを修正。もっと太くして見やすくする
        const getCoords = (pos) => isCorrected ? { x: pos.x, y: pos.y } : { x: pos.x * canvas.width, y: pos.y * canvas.height };
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.1)'; // 青色の透明度を下げて、軌跡を目立たせる
        ctx.beginPath();
        positions.forEach((p, i) => { if (p.leftAnkle) { const {x, y} = getCoords(p.leftAnkle); if (i === 0 || !positions[i-1].leftAnkle) ctx.moveTo(x, y); else ctx.lineTo(x, y); } });
        ctx.stroke();
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.1)'; // 赤色の透明度を下げて、軌跡を目立たせる
        ctx.beginPath();
        positions.forEach((p, i) => { if (p.rightAnkle) { const {x, y} = getCoords(p.rightAnkle); if (i === 0 || !positions[i-1].rightAnkle) ctx.moveTo(x, y); else ctx.lineTo(x, y); } });
        ctx.stroke();
        // さらに時間内最後の位置を強調表示
        if (positions.length > 0) {
            const lastPos = positions[positions.length - 1];
            if (lastPos.leftAnkle) {
                const {x, y} = getCoords(lastPos.leftAnkle);
                ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI); // 半径10の円を描く
                ctx.fill();
            }
            if (lastPos.rightAnkle) {
                const {x, y} = getCoords(lastPos.rightAnkle);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI); // 半径10の円を描く
                ctx.fill();
            }
        }
    }

    function drawHeatmap(positions, isCorrected, canvas) {
        const ctx = canvas.getContext('2d');
        const gridW = canvas.width / HEATMAP_GRID_SIZE;
        const gridH = canvas.height / HEATMAP_GRID_SIZE;
        const heatmapData = Array(HEATMAP_GRID_SIZE).fill(null).map(() => Array(HEATMAP_GRID_SIZE).fill(0));
        let maxHits = 0;
        const getCoords = (pos) => isCorrected ? { x: pos.x, y: pos.y } : { x: pos.x * canvas.width, y: pos.y * canvas.height };
        positions.forEach(p => {
            [p.leftAnkle, p.rightAnkle].forEach(ankle => {
                if (ankle) {
                    const {x, y} = getCoords(ankle);
                    const gridX = Math.floor(x / gridW);
                    const gridY = Math.floor(y / gridH);
                    if (gridX >= 0 && gridX < HEATMAP_GRID_SIZE && gridY >= 0 && gridY < HEATMAP_GRID_SIZE) {
                        heatmapData[gridY][gridX]++;
                        if (heatmapData[gridY][gridX] > maxHits) maxHits = heatmapData[gridY][gridX];
                    }
                }
            });
        });
        if (maxHits === 0) return;
        for (let y = 0; y < HEATMAP_GRID_SIZE; y++) {
            for (let x = 0; x < HEATMAP_GRID_SIZE; x++) {
                if (heatmapData[y][x] > 0) {
                    const intensity = heatmapData[y][x] / maxHits;
                    const g = Math.floor(255 * (1 - intensity));
                    ctx.fillStyle = `rgba(255, ${g}, 0, ${Math.max(0.1, intensity * 0.7)})`;
                    ctx.fillRect(x * gridW, y * gridH, gridW, gridH);
                }
            }
        }
    }
    
    // --- Cropping and Correction Functions ---
    function startCroppingMode() { isCroppingMode = true; cropOverlayCanvas.classList.remove('hidden'); cropInstructions.classList.remove('hidden'); applyCorrectionButton.classList.remove('hidden'); resetCorrectionButton.classList.remove('hidden'); 
    const w = cropOverlayCanvas.width, h = cropOverlayCanvas.height, mX = w * 0.15, mY = h * 0.15;
    // cropPointがからの場合のみ、初期化
     if (!cropPoints || cropPoints.length !== 4) {
         // 初期のトリミングポイントを設定
    cropPoints = [{ x: mX, y: mY }, { x: w - mX, y: mY }, { x: w - mX, y: h - mY }, { x: mX, y: h - mY }]; 
     }
     drawCropOverlay();
     }
    function stopCroppingMode() { isCroppingMode = false; isDragging = false; draggedPointIndex = -1; cropOverlayCanvas.classList.add('hidden'); cropInstructions.classList.add('hidden'); applyCorrectionButton.classList.add('hidden'); resetCorrectionButton.classList.add('hidden');}
    startCropButton.addEventListener('click', () => { if (isCroppingMode) { stopCroppingMode(); startCropButton.textContent = "コートに合わせてトリミング"; } else { startCroppingMode(); startCropButton.textContent = "調整をキャンセル"; }});
    function drawCropOverlay() {
         if (!isCroppingMode) return; 
         const ctx = ctxCropOverlay; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.beginPath(); ctx.moveTo(cropPoints[0].x, cropPoints[0].y); 
         for (let i = 1; i < cropPoints.length; i++) { ctx.lineTo(cropPoints[i].x, cropPoints[i].y); } ctx.closePath(); ctx.fillStyle = "rgba(59, 130, 246, 0.2)"; ctx.fill(); ctx.strokeStyle = "rgba(37, 99, 235, 1)"; ctx.lineWidth = 4; ctx.stroke(); cropPoints.forEach((p, i) => { ctx.beginPath(); ctx.arc(p.x, p.y, CROP_HANDLE_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = (i === draggedPointIndex) ? "#dc2626" : "#2563eb"; ctx.fill(); });
        }
    cropOverlayCanvas.addEventListener('mousedown', (e) => {
         if (!isCroppingMode) return; const rect = cropOverlayCanvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (cropOverlayCanvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (cropOverlayCanvas.height / rect.height); draggedPointIndex = cropPoints.findIndex(p => Math.sqrt((p.x - mouseX)**2 + (p.y - mouseY)**2) < CROP_HANDLE_RADIUS); if (draggedPointIndex !== -1) { isDragging = true; cropOverlayCanvas.style.cursor = 'grabbing'; } 
        });
    cropOverlayCanvas.addEventListener('mousemove', (e) => {
         if (!isCroppingMode) return; const rect = cropOverlayCanvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (cropOverlayCanvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (cropOverlayCanvas.height / rect.height); if (isDragging && draggedPointIndex !== -1) { cropPoints[draggedPointIndex] = { x: mouseX, y: mouseY }; drawCropOverlay(); } else { const onHandle = cropPoints.some(p => Math.sqrt((p.x - mouseX)**2 + (p.y - mouseY)**2) < CROP_HANDLE_RADIUS); cropOverlayCanvas.style.cursor = onHandle ? 'grab' : 'default'; } });
    const stopDrag = () => { if (isDragging) { isDragging = false; draggedPointIndex = -1; cropOverlayCanvas.style.cursor = 'grab'; } };
    cropOverlayCanvas.addEventListener('mouseup', stopDrag);
    cropOverlayCanvas.addEventListener('mouseout', stopDrag);
    applyCorrectionButton.addEventListener('click', () => {
        const srcPoints = cropPoints;
        const dstPoints = [{ x: 0, y: 0 }, { x: trajectoryCanvas.width, y: 0 }, { x: trajectoryCanvas.width, y: trajectoryCanvas.height }, { x: 0, y: trajectoryCanvas.height },];
        try {
            homographyMatrix = getHomographyMatrix(srcPoints, dstPoints);
            // *** MODIFIED *** Apply homography to both ankles and wrists → 手首には補正を適用しない様に修正
            correctedAnklePositions = applyHomographyToAllPoints(anklePositions, homographyMatrix, poseCanvas.width, poseCanvas.height, 'Ankle');
            // Websorageに補正後の座標を保存
            localStorage.setItem('cropPoints', JSON.stringify(cropPoints));



            // *** MODIFIED *** Apply homography to wrists but keep original positions
            // 手首には補正を適用しない予定
            correctedWristPositions = applyHomographyToAllPoints(wristPositions, homographyMatrix, poseCanvas.width, poseCanvas.height, 'Wrist');
            // Update the trajectory and heatmap canvases




            isCorrectionApplied = true;
            stopCroppingMode();
            startCropButton.textContent = "コートに合わせてトリミング";
            if (!visualizationControls.classList.contains('hidden')) { drawAnalysis(parseFloat(timeSlider.value)); } else { analyzeButton.click(); }
            loadingTxt.textContent = "座標の補正が適用されました。";
        } catch (error) { console.error("Failed to compute homography:", error); loadingTxt.textContent = "エラー: 座標の補正に失敗しました。四隅が交差しないように指定してください。"; }
    });
    resetCorrectionButton.addEventListener('click', () => {
         isCorrectionApplied = false; homographyMatrix = null; correctedAnklePositions = []; correctedWristPositions = []; stopCroppingMode(); startCropButton.textContent = "コートに合わせてトリミング"; if (!visualizationControls.classList.contains('hidden')) { drawAnalysis(parseFloat(timeSlider.value)); } loadingTxt.textContent = "座標の補正をリセットしました。"; 
         // localStorageから補正後の座標を削除
         localStorage.removeItem('cropPoints');
         // cropPointsを初期化
         const w = cropOverlayCanvas.width, h = cropOverlayCanvas.height, mX = w * 0.15, mY = h * 0.15; cropPoints = [{ x: mX, y: mY }, { x: w - mX, y: mY }, { x: w - mX, y: h - mY }, { x: mX, y: h - mY }];
        });
    
    // *** MODIFIED *** A generic function to apply homography based on key prefix
    function applyHomographyToAllPoints(points, H, videoW, videoH, keyPrefix) {
        const leftKey = `left${keyPrefix}`;
        const rightKey = `right${keyPrefix}`;
        return points.map(p => {
            const newP = { time: p.time };
            if (p[leftKey] && keyPrefix !== 'Wrist') { // wristの場合は補正を適用しないように修正
                // ただし、座標変換は行う
                const absCoords = { x: p[leftKey].x * videoW, y: p[leftKey].y * videoH };
                newP[leftKey] = applyHomography(absCoords, H);
            }
            else if (p[leftKey]) {
                // wristの場合は補正を適用しないように修正
                newP[leftKey] = { x: p[leftKey].x * videoW, y: p[leftKey].y * videoH };
            }
            if (p[rightKey] && keyPrefix !== 'Wrist') { // wristの場合は補正を適用しないように修正
                // ただし、座標変換は行う
                const absCoords = { x: p[rightKey].x * videoW, y: p[rightKey].y * videoH };
                newP[rightKey] = applyHomography(absCoords, H);
            }
            else if (p[rightKey]) {
                // wristの場合は補正を適用しないように修正
                newP[rightKey] = { x: p[rightKey].x * videoW, y: p[rightKey].y * videoH };
            }
            return newP;
        });
    }

    function applyHomography(point, H) { 
        const d = H[6] * point.x + H[7] * point.y + 1; 
        return { 
            x: (H[0] * point.x + H[1] * point.y + H[2]) / d, 
            y: (H[3] * point.x + H[4] * point.y + H[5]) / d 
        }; 
    }

    // --- *** ADDED *** Shot Analysis Functions ---

    function calculateWristVelocities(positions) {
        const velocities = [];
        if (positions.length < 2) return velocities;

        for (let i = 1; i < positions.length; i++) {
            const p1 = positions[i-1];
            const p2 = positions[i];
            const dt = p2.time - p1.time;

            if (dt <= 0) continue;

            let leftV = 0, rightV = 0;

            if (p1.leftWrist && p2.leftWrist) {
                const c1 = isCorrected ? p1.leftWrist : { x: p1.leftWrist.x * poseCanvas.width, y: p1.leftWrist.y * poseCanvas.height };
                const c2 = isCorrected ? p2.leftWrist : { x: p2.leftWrist.x * poseCanvas.width, y: p2.leftWrist.y * poseCanvas.height };
                const distance = Math.sqrt((c2.x - c1.x)**2 + (c2.y - c1.y)**2);
                leftV = distance / dt;
            }
            if (p1.rightWrist && p2.rightWrist) {
                const c1 = isCorrected ? p1.rightWrist : { x: p1.rightWrist.x * poseCanvas.width, y: p1.rightWrist.y * poseCanvas.height };
                const c2 = isCorrected ? p2.rightWrist : { x: p2.rightWrist.x * poseCanvas.width, y: p2.rightWrist.y * poseCanvas.height };
                const distance = Math.sqrt((c2.x - c1.x)**2 + (c2.y - c1.y)**2);
                rightV = distance / dt;
            }
            velocities.push({ time: p2.time, left: leftV, right: rightV });
        }
        return velocities;
    }

    function detectShots(velocities, threshold) {
        const shots = [];
        let isDuringShot = false;

        for (const v of velocities) {
            const maxVelocity = Math.max(v.left, v.right);
            if (maxVelocity >= threshold && !isDuringShot) {
                shots.push(v.time);
                isDuringShot = true;
            } else if (maxVelocity < threshold) {
                isDuringShot = false;
            }
        }
        return shots;
    }

    function drawWristVelocityGraph(velocities, currentTime) {
        const ctx = ctxWristVelocity;
        const canvas = ctx.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (velocities.length === 0) return;

        const maxT = velocities.length > 0 ? velocities[velocities.length - 1].time : (anklePositions[anklePositions.length-1]?.time || 1);
        const maxV = Math.max(...velocities.map(v => Math.max(v.left, v.right)), SHOT_VELOCITY_THRESHOLD * 1.2);
        
        const padding = { top: 20, bottom: 40, left: 50, right: 20 };
        const graphWidth = canvas.width - padding.left - padding.right;
        const graphHeight = canvas.height - padding.top - padding.bottom;

        const timeToX = (t) => padding.left + (t / maxT) * graphWidth;
        const velocityToY = (v) => canvas.height - padding.bottom - (v / maxV) * graphHeight;

        ctx.beginPath(); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.moveTo(padding.left, padding.top); ctx.lineTo(padding.left, canvas.height - padding.bottom); ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom); ctx.stroke();
        ctx.fillStyle = '#4b5563'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText("Time (s)", canvas.width / 2, canvas.height - padding.bottom + 10);
        ctx.save(); ctx.translate(padding.left - 30, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.fillText("手首の速度 (pixels/s)", 0, 0); ctx.restore();

        const thresholdY = velocityToY(SHOT_VELOCITY_THRESHOLD);
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.strokeStyle = '#ef4444'; ctx.moveTo(padding.left, thresholdY); ctx.lineTo(canvas.width - padding.right, thresholdY); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#ef4444'; ctx.textAlign = 'left'; ctx.fillText(`ショット閾値`, padding.left + 5, thresholdY - 15);

        ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'; ctx.lineWidth = 2; ctx.beginPath();
        velocities.forEach((v, i) => { const x = timeToX(v.time); const y = velocityToY(v.left); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
        ctx.stroke();
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; ctx.beginPath();
        velocities.forEach((v, i) => { const x = timeToX(v.time); const y = velocityToY(v.right); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
        ctx.stroke();
        
        const currentX = timeToX(currentTime);
        if (currentX >= padding.left && currentX <= canvas.width - padding.right) {
            ctx.beginPath(); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 1.5; ctx.moveTo(currentX, padding.top); ctx.lineTo(currentX, canvas.height - padding.bottom); ctx.stroke();
        }
    }

    function createShotButtons(shots) {
        shotButtonsContainer.innerHTML = '';
        if (shots.length > 0) {
            const title = document.createElement('span');
            title.className = 'text-sm font-medium text-gray-700 mr-2 self-center';
            title.textContent = 'ショット時点へ移動:';
            shotButtonsContainer.appendChild(title);
        }

        shots.forEach((time, index) => {
            const button = document.createElement('button');
            button.className = 'glass-button text-xs py-1 px-2 transition-transform hover:scale-105';
            button.textContent = `ショット ${index + 1} (${time.toFixed(1)}s)`;
            button.dataset.time = time;
            button.addEventListener('click', () => {
                const jumpTime = parseFloat(button.dataset.time);
                video.currentTime = jumpTime;
                timeSlider.value = jumpTime;
                sliderCurrentTime.textContent = `${jumpTime.toFixed(1)}s`;
                drawAnalysis(jumpTime);
            });
            shotButtonsContainer.appendChild(button);
        });
    }

    // *** ADDED *** Export Functions
    function downloadFile(content, filename, contentType) {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function exportToJSON() {
        const data = {
            timestamp: new Date().toISOString(),
            videoDuration: videoDuration,
            shotVelocityThreshold: SHOT_VELOCITY_THRESHOLD,
            anklePositions: isCorrectionApplied ? correctedAnklePositions : anklePositions,
            wristPositions: isCorrectionApplied ? correctedWristPositions : wristPositions,
            shotTimes: shotTimes,
            correctionApplied: isCorrectionApplied,
            homographyMatrix: homographyMatrix
        };
        
        const jsonString = JSON.stringify(data, null, 2);
        downloadFile(jsonString, 'badminton_analysis.json', 'application/json');
        loadingTxt.textContent = "JSONファイルをエクスポートしました。";
    }

    function exportToCSV() {
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        
        let csvContent = "Time,LeftAnkleX,LeftAnkleY,RightAnkleX,RightAnkleY,LeftWristX,LeftWristY,RightWristX,RightWristY\n";
        
        const maxLength = Math.max(ankleData.length, wristData.length);
        for (let i = 0; i < maxLength; i++) {
            const ankle = ankleData[i] || {};
            const wrist = wristData[i] || {};
            const time = ankle.time || wrist.time || '';
            
            csvContent += `${time},`;
            csvContent += `${ankle.leftAnkle?.x || ''},${ankle.leftAnkle?.y || ''},`;
            csvContent += `${ankle.rightAnkle?.x || ''},${ankle.rightAnkle?.y || ''},`;
            csvContent += `${wrist.leftWrist?.x || ''},${wrist.leftWrist?.y || ''},`;
            csvContent += `${wrist.rightWrist?.x || ''},${wrist.rightWrist?.y || ''}\n`;
        }
        
        downloadFile(csvContent, 'badminton_analysis.csv', 'text/csv');
        loadingTxt.textContent = "CSVファイルをエクスポートしました。";
    }

    function exportImages() {
        const images = [];
        
        // Export trajectory canvas
        trajectoryCanvas.toBlob((blob) => {
            images.push({ name: 'trajectory.png', blob });
            
            // Export heatmap canvas
            heatmapCanvas.toBlob((blob2) => {
                images.push({ name: 'heatmap.png', blob: blob2 });
                
                // Export wrist velocity chart
                wristVelocityCanvas.toBlob((blob3) => {
                    images.push({ name: 'wrist_velocity.png', blob: blob3 });
                    
                    // Download each image separately
                    images.forEach((img, index) => {
                        setTimeout(() => {
                            const url = URL.createObjectURL(img.blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = img.name;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, index * 500);
                    });
                    loadingTxt.textContent = "画像ファイルをエクスポートしました。";
                });
            });
        });
    }

    function generateReport() {
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        
        const report = `バドミントン動作分析レポート
=====================================

分析日時: ${new Date().toLocaleString('ja-JP')}
動画時間: ${videoDuration.toFixed(2)}秒
ショット検出閾値: ${SHOT_VELOCITY_THRESHOLD} ピクセル/秒
座標補正: ${isCorrectionApplied ? '適用済み' : '未適用'}

分析結果:
---------
記録された足首位置データ: ${ankleData.length}ポイント
記録された手首位置データ: ${wristData.length}ポイント
検出されたショット数: ${shotTimes.length}回

ショット時刻:
${shotTimes.map((time, i) => `  ショット${i + 1}: ${time.toFixed(2)}秒`).join('\n')}

統計情報:
---------
最初の記録時刻: ${ankleData.length > 0 ? ankleData[0].time.toFixed(2) : 'N/A'}秒
最後の記録時刻: ${ankleData.length > 0 ? ankleData[ankleData.length - 1].time.toFixed(2) : 'N/A'}秒
平均ショット間隔: ${shotTimes.length > 1 ? ((shotTimes[shotTimes.length - 1] - shotTimes[0]) / (shotTimes.length - 1)).toFixed(2) : 'N/A'}秒

注意: このレポートは自動生成されたものです。
詳細な分析については専門家にご相談ください。
`;

        downloadFile(report, 'badminton_analysis_report.txt', 'text/plain');
        loadingTxt.textContent = "分析レポートを生成しました。";
    }

    // Export button event listeners
    // Export button event listeners
    exportJSONButton.addEventListener('click', exportToJSON);
    exportCSVButton.addEventListener('click', exportToCSV);
    exportImageButton.addEventListener('click', exportImages);
    generateReportButton.addEventListener('click', generateReport);

    // Touch event listeners for mobile cropping
    cropOverlayCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    cropOverlayCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    cropOverlayCanvas.addEventListener('touchend', handleTouchEnd);
    cropOverlayCanvas.addEventListener('touchcancel', handleTouchEnd);


    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }

    // Utility function to get touch coordinates
    function getTouchCoords(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.touches[0].clientX - rect.left,
            y: evt.touches[0].clientY - rect.top
        };
    }

    function handleMouseDown(e) {
        e.preventDefault();
        const mousePos = getMousePos(cropOverlayCanvas, e);
        draggedPointIndex = cropPoints.findIndex(p => Math.sqrt(Math.pow(mousePos.x - p.x, 2) + Math.pow(mousePos.y - p.y, 2)) < CROP_HANDLE_RADIUS);
        if (draggedPointIndex !== -1) {
            isDragging = true;
            cropOverlayCanvas.style.cursor = 'grabbing';
        }
    }

    function handleMouseMove(e) {
        e.preventDefault();
        if (!isDragging) return;
        const mousePos = getMousePos(cropOverlayCanvas, e);
        cropPoints[draggedPointIndex] = mousePos;
        drawCropOverlay();
    }

    function handleMouseUp(e) {
        e.preventDefault();
        isDragging = false;
        draggedPointIndex = -1;
    }

    function handleMouseOut(e) {
        e.preventDefault();
        isDragging = false;
        draggedPointIndex = -1;
    }

    // Touch event handlers
    function handleTouchStart(e) {
        e.preventDefault();
        const touchPos = getTouchCoords(cropOverlayCanvas, e);
        for (let i = 0; i < cropPoints.length; i++) {
            const dist = Math.sqrt(Math.pow(touchPos.x - cropPoints[i].x, 2) + Math.pow(touchPos.y - cropPoints[i].y, 2));
            if (dist < CROP_HANDLE_RADIUS) {
                isDragging = true;
                draggedPointIndex = i;
                break;
            }
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!isDragging) return;
        const touchPos = getTouchCoords(cropOverlayCanvas, e);
        cropPoints[draggedPointIndex] = touchPos;
        drawCropOverlay();
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        isDragging = false;
        draggedPointIndex = -1;
    }

    function getHomographyMatrix(p1, p2, p3, p4, q1, q2, q3, q4) {
        // ...
        // 参照: https://stackoverflow.com/questions/27249148/how-to-get-homography-matrix-from-4-points-in-javascript
        // 参照: http://www.corrmap.com/features/homography_transformation.php
        const dx1 = p2.x - p3.x;
        const dx2 = p4.x - p3.x;
        const dx3 = p1.x - p2.x + p3.x - p4.x;
        const dy1 = p2.y - p3.y;
        const dy2 = p4.y - p3.y;
        const dy3 = p1.y - p2.y + p3.y - p4.y;

        const dq1 = q2.x - q3.x;
        const dq2 = q4.x - q3.x;
        const dq3 = q1.x - q2.x + q3.x - q4.x;
        const dr1 = q2.y - q3.y;
        const dr2 = q4.y - q3.y;
        const dr3 = q1.y - q2.y + q3.y - q4.y;

        const det = dx1 * dy2 - dx2 * dy1;
        const a = (dq1 * dy2 - dq2 * dy1) / det;
        const b = (dq2 * dx1 - dq1 * dx2) / det;
        const c = q3.x - p3.x * a - p3.y * b;

        const d = (dr1 * dy2 - dr2 * dy1) / det;
        const e_val = (dr2 * dx1 - dr1 * dx2) / det; // 'e' is a reserved keyword in strict mode
        const f = q3.y - p3.x * d - p3.y * e_val;

        const det_g = dx1 * dy3 - dx3 * dy2;
        const g_val = (dq3 * dy2 - dq1 * dy3) / det_g; // 'g' is a reserved keyword
        const h_val = (dq1 * dx3 - dq3 * dx1) / det_g; // 'h' is a reserved keyword

        const det_h = dy1 * dx3 - dy3 * dx1;
        const g_val_alt = (dr3 * dx1 - dr1 * dx3) / det_h;
        const h_val_alt = (dr1 * dy3 - dr3 * dy1) / det_h;
        
        // To avoid issues with variable names like 'e', 'g', 'h'
        const dy_val = dy3; // Corrected: dy was not defined, should be dy3 or a new var
        
        const g = ( (dq3*dy2 - dq2*dy_val) / (dx1*dy2 - dx2*dy1) - a ) / ( (dx3*dy2 - dx2*dy_val) / (dx1*dy2 - dx2*dy1) );
        const h = ( (dq3*dx1 - dq1*dx3) / (dx1*dy2 - dx2*dy1) - b ) / ( (dx3*dx1 - dx1*dx3) / (dx1*dy2 - dx2*dy1) );


        return [
            [a + g * q1.x, b + h * q1.x, c],
            [d + g * q1.y, e_val + h * q1.y, f],
            [g, h, 1]
        ];
    }

    function applyHomography(point, matrix) {
        const d = matrix[6] * point.x + matrix[7] * point.y + 1;
        return {
            x: (matrix[0] * point.x + matrix[1] * point.y + matrix[2]) / d,
            y: (matrix[3] * point.x + matrix[4] * point.y + matrix[5]) / d
        };
    }
</script>

</body>
</html>